/**
 * @file LimbTorqueControllerService.idl
 * @brief Services for the limb torque controller interface
 */
module OpenHRP
{

  interface LimbTorqueControllerService
  {
    typedef sequence<double, 3> DblSequence3;
    typedef double DblArray3[3];
    typedef sequence<double> DblSequence;
    typedef sequence<string> StrSequence;
    typedef sequence<sequence<double, 3> > Dbl3Sequence;
    typedef sequence<sequence<double> > DblMatrix;

    /**
     * @enum ControllerMode
     * @brief Mode of controller
     */
    enum ControllerMode {
        MODE_IDLE,
        MODE_ACTIVE
    };

    /**
     * @enum ArmMode
     * @brief Mode of arm control
     */
    enum ArmMode {
        IDLE_NORMAL,
        IDLE_HARD,
        IDLE_COMPLIANT,
        MANIP_FREE,
        MANIP_CONTACT,
        EMERGENCY
    };

    /**
     * @struct limbtorqueParam
     * @brief Limb torque controller parameters for one end-effector.
     */
    struct limbtorqueParam {
        double Pgain;
        double Dgain;
        ControllerMode controller_mode;
        ArmMode amode;
        DblSequence ee_pgain;
        DblSequence ee_dgain;
    };

    /**
     * @struct collisionParam
     * @brief collision parameters for one end-effector.
     */
    struct collisionParam {
        DblSequence Thresh;
        double Cgain;
        double Rgain;
        long MaxCount;
        long CheckMode;
        long HandleMode;
    };

    /**
     * @enum TaskTargetType
     * @brief Mode of arm control
     */
    enum TaskTargetType {
        MOVE_POS,
        MOVE_ROT,
        MOVE_POSROT,
        FIX
    };

    /**
     * @struct taskDescription
     * @brief task description
     */
    struct taskDescription {
        TaskTargetType type;
        boolean dual;
        DblSequence3 velocity_check_dir;
        DblSequence F_init;
        double vel_force_gain; //F_now = F_max - vel_force_gain*act_ee_vel
        double w_force_gain; //F_now = F_max - w_force_gain*act_ee_w
        DblSequence3 rel_pos_target;
        DblSequence rel_ori_target; //quaternion in vector4
        double vel_check_thresh; //velocity error threshold from MANIP_FREE to MANIP_CONTACT
        double vel_check_limit; //velocity error threshold from MANIP_FREE to EMERGENCY
        double cont_vel_error_limit; //velocity threshold from MANIP_CONTACT to EMERGENCY
        double cont_w_error_limit; //angular velocity threshold from MANIP_CONTACT to EMERGENCY
        double pos_target_thresh; //position distance threshold from MANIP_CONTACT to IDLE_NORMAL
        double pos_error_limit; //position error threshold from MANIP_CONTACT to EMERGENCY
        double ori_target_thresh; //orientation distance threshold from MANIP_CONTACT to IDLE_NORMAL
        double ori_error_limit; //orientation error threshold from MANIP_CONTACT to EMERGENCY
    };

    /**
    * @struct taskDescription
    * @brief task description
    */
    struct taskState{
        DblSequence3 world_pos_target; //ee position target in MANIP_CONTACT
        DblSequence world_ori_target; //ee orientation target in MANIP_CONTACT
        DblSequence3 world_pos_targ_dir; //normalized direction of target from initial state: in MANIP_CONTACT
        DblSequence3 world_ori_targ_dir; //normalized direction of target from initial state: in MANIP_CONTACT: use only for angular velocity
        DblSequence F_now; //current reference force
        boolean pos_over_limit; //whether position error exceeded limit or not
        boolean pos_reach_target; //whether position reached near target or not
        boolean ori_over_limit; //whether orientation error exceeded limit or not
        boolean ori_reach_target; //whether orientation reached near target or not
        boolean vel_over_thresh; // wheter ee velocity exceeds threshold or not (from MANIP_FREE to MANIP_CONTACT) (from IDLE_COMPLIANT to IDLE_NORMAL)
        boolean vel_over_limit; // whether ee velocity exceeds limit or not (in MANIP_CONTACT and MANIP_FREE)
        boolean w_over_limit; // whether ee angular velocity exceeds limit or not (in MANIP_CONTACT and MANIP_FREE)
        boolean torque_over_limit; // whether joint torque exceeds limit or not (in MANIP_CONTACT)
        DblSequence F_eeR; //end-effector rotation for reference force in EmergencyEECompensation
        long f2c_transition_count; //transition from MANIP_FREE to MANIP_CONTACT (F_now = F_init @ count==0)
        long max_f2c_t_count; //maximum value of f2c_transition_count
        long em_transition_count; //transition from EMERGENCY to IDLE_NORMAL
        long max_em_t_count; //maximum value of em_transition_count
        DblSequence F_em_init; //F_now at the moment of emergency transition
        double init_point_vel, init_point_w; //ee velocity to target direction at the time F_now reached F_init
        DblSequence3 initial_pos; //act ee pos(in world coordinate) at the moment of mode transition
        DblSequence initial_ori; //act ee orientation(in world coordinate) at the moment of mode transition
        DblSequence emergency_q; //joint angles at the moment of transition to emrgency mode
    }                           ;

    /**
     * @struct collisionStatus
     * @brief collision status for one end-effector.
     */
    struct collisionStatus {
        DblSequence CollisionTorque;
        boolean IsCollision;
        string CollisionLink;
    };


      /**
       * @brief start limb torque controller
       * @param name limb torque controller param's name, which basically corresponds to force sensor name
       * @return true if set successfully, false otherwise
       */
      boolean startLimbTorqueController(in string name);

      /**
       * @brief stop limb torque controller
       * @param name limb torque controller param's name, which basically corresponds to force sensor name
       * @return true if set successfully, false otherwise
       */
      boolean stopLimbTorqueController(in string name);

    /**
     * @brief set limb torque parameters.
     * @param i_param input new limb torque parameters
     * @param name limb torque controller param's name, which basically corresponds to force sensor name
     * @return true if set successfully, false otherwise
     */
    boolean setLimbTorqueControllerParam(in string name, in limbtorqueParam i_param);

    /**
     * @brief get limb torque parameters.
     * @param i_param ouput limb torque parameters
     * @param name limb torque controller param's name, which basically corresponds to force sensor name
     * @return true if set successfully, false otherwise
     */
    boolean getLimbTorqueControllerParam(in string name, out limbtorqueParam i_param);

    /**
     * @brief set collision parameters.
     * @param i_param input new collision parameters
     * @param name collision param's name, which basically corresponds to force sensor name
     * @return true if set successfully, false otherwise
     */
    boolean setCollisionParam(in string name, in collisionParam i_param);

    /**
     * @brief get collision parameters.
     * @param i_param ouput collision parameters
     * @param name collision param's name, which basically corresponds to force sensor name
     * @return true if set successfully, false otherwise
     */
    boolean getCollisionParam(in string name, out collisionParam i_param);

    /**
     * @brief get output of collision detector.
     * @param name limb torque controller param's name, which basically corresponds to force sensor name
     * @param c_vector torque vector
     * @return true if got successfully, false otherwise
     */
    boolean getCollisionTorque(in string name, out DblSequence c_vector);

    /**
     * @brief get collision status.
     * @param name limb torque controller param's name, which basically corresponds to force sensor name
     * @param i_param output collision status
     * @return true if got successfully, false otherwise
     */
    boolean getCollisionStatus(in string name, out collisionStatus i_param);

    /**
     * @brief start spitting log
     * @param name: base file path to store log files: if name=="/tmp", then log files will be stored under "/tmp/LimbTorqueControllerDebug/"
     * @param logname: what kind of log to take: "collision" or "operational"
     * @return true if got successfully, false otherwise
     */
    boolean startLog(in string name, in string logname);

    /**
     * @brief stop spitting log
     * @return true if got successfully, false otherwise
     */
    boolean stopLog();

    /**
     * @brief start overwriting reference joint angles using estimated reference velocity
     * @param name: end effector
     * @return true if got successfully, false otherwise
     */
    boolean startRefdqEstimation(in string name);

    /**
     * @brief stop overwriting reference joint angles using estimated reference velocity
     * @param name: end effector
     * @return true if got successfully, false otherwise
     */
    boolean stopRefdqEstimation(in string name);

      boolean releaseEmergency(in string name, in boolean cancel);
    boolean giveTaskDescription(in string name, in taskDescription taskd);
    boolean getTaskDescription(in string name, out taskDescription taskd);
    boolean getTaskState(in string name, out taskState tasks);
      boolean startModeChange(in string name);
      boolean stopModeChange(in string name);
  };
};
